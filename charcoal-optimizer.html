<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Charcoal Bag Packaging Optimizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .input-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .input-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .input-group h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .input-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .input-row label {
            flex: 1;
            color: #495057;
            font-weight: 500;
        }

        .input-row input {
            width: 100px;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }

        .input-row input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .unit {
            margin-left: 8px;
            color: #6c757d;
            font-size: 13px;
        }

        .calculate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 30px;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .calculate-btn:active {
            transform: translateY(0);
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .result-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 20px;
            border-radius: 10px;
            color: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-card.primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .result-card.success {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .result-card h4 {
            font-size: 14px;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .result-card .value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .result-card .detail {
            font-size: 13px;
            opacity: 0.9;
        }

        .visualization {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .visualization h3 {
            color: #495057;
            margin-bottom: 15px;
        }

        .viz-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .viz-box {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .viz-box h4 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 16px;
        }

        canvas {
            width: 100%;
            border-radius: 5px;
            background: #fff;
        }

        .optimal-dimensions {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .optimal-dimensions h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .dim-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .dim-item {
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 8px;
        }

        .dim-item .label {
            color: #856404;
            font-size: 13px;
            margin-bottom: 5px;
        }

        .dim-item .dim-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .viz-3d {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .viz-3d h3 {
            color: #495057;
            margin-bottom: 15px;
        }

        #viewer3d {
            width: 100%;
            height: 600px;
            background: #1a1a2e;
            border-radius: 8px;
            position: relative;
        }

        .explosion-control {
            margin-top: 15px;
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .explosion-control label {
            display: block;
            color: #495057;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .explosion-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e9ecef;
            outline: none;
            -webkit-appearance: none;
        }

        .explosion-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
        }

        .explosion-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
        }

        .explosion-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #667eea;
        }

        .hero-header {
            background: linear-gradient(135deg, #ff6b6b 0%, #feca57 25%, #48dbfb 50%, #ff9ff3 75%, #ff6b6b 100%);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 15px 40px rgba(255, 107, 107, 0.4);
            text-align: center;
            border: 5px solid #ffd700;
            position: relative;
            overflow: hidden;
        }

        .hero-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .hero-title {
            font-size: 56px;
            font-weight: 900;
            color: #fff;
            text-shadow:
                4px 4px 0px #000,
                6px 6px 10px rgba(0,0,0,0.5),
                0 0 20px rgba(255,215,0,0.8);
            margin: 0;
            letter-spacing: 2px;
            animation: pulse 2s ease-in-out infinite;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
        }

        .hero-subtitle {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255,215,0,0.6);
            margin: 15px 0 0 0;
            position: relative;
            z-index: 1;
        }

        .hero-tagline {
            font-size: 18px;
            color: #ffe066;
            text-shadow: 2px 2px 3px #000;
            margin: 10px 0 0 0;
            font-style: italic;
            position: relative;
            z-index: 1;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .badge {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #000;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);
            border: 2px solid #ff6b6b;
            animation: pulse 2s ease-in-out infinite;
        }

        .badge:nth-child(2) {
            animation-delay: 0.3s;
        }

        .badge:nth-child(3) {
            animation-delay: 0.6s;
        }

        .badge:nth-child(4) {
            animation-delay: 0.9s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero-header">
            <h1 class="hero-title">ULTIMATE CHARCOAL PACKING MAXIMIZER 3000!</h1>
            <p class="hero-subtitle">PACK MORE! EARN MORE! SAVE MORE!</p>
            <p class="hero-tagline">"The SECRET WEAPON Every Charcoal Producer Has Been WAITING FOR!"</p>
            <div class="badges">
                <span class="badge">100% GUARANTEED RESULTS!</span>
                <span class="badge">REVOLUTIONARY 3D TECHNOLOGY!</span>
                <span class="badge">AI-POWERED OPTIMIZATION!</span>
                <span class="badge">INSTANT CALCULATIONS!</span>
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <h3>Container Dimensions</h3>
                <div class="input-row">
                    <label>Length:</label>
                    <input type="number" id="containerL" value="1200" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Width:</label>
                    <input type="number" id="containerW" value="235" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Height:</label>
                    <input type="number" id="containerH" value="239" step="1">
                    <span class="unit">cm</span>
                </div>
            </div>

            <div class="input-group">
                <h3>Pallet Dimensions</h3>
                <div class="input-row">
                    <label>Length:</label>
                    <input type="number" id="palletL" value="120" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Width:</label>
                    <input type="number" id="palletW" value="80" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Height (max):</label>
                    <input type="number" id="palletH" value="120" step="1">
                    <span class="unit">cm</span>
                </div>
            </div>

            <div class="input-group">
                <h3>Bag Specifications</h3>
                <div class="input-row">
                    <label>Mode:</label>
                    <select id="bagMode" onchange="toggleBagMode()" style="width: 150px; padding: 8px; border: 1px solid #ced4da; border-radius: 5px;">
                        <option value="optimize">Optimize</option>
                        <option value="manual">Manual Override</option>
                    </select>
                </div>

                <div id="optimizeFields">
                    <div class="input-row">
                        <label>Weight per bag:</label>
                        <input type="number" id="bagWeight" value="5" step="0.1">
                        <span class="unit">kg</span>
                    </div>
                    <div class="input-row">
                        <label>Charcoal density:</label>
                        <input type="number" id="density" value="300" step="1">
                        <span class="unit">kg/m³</span>
                    </div>
                    <div class="input-row">
                        <label>Min bag dimension:</label>
                        <input type="number" id="minBagDim" value="10" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Max bag dimension:</label>
                        <input type="number" id="maxBagDim" value="60" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Search step:</label>
                        <input type="number" id="searchStep" value="1" step="0.5" min="0.5">
                        <span class="unit">cm</span>
                    </div>
                </div>

                <div id="manualFields" style="display: none;">
                    <div class="input-row">
                        <label>Bag length:</label>
                        <input type="number" id="manualBagL" value="30" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Bag width:</label>
                        <input type="number" id="manualBagW" value="20" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Bag height:</label>
                        <input type="number" id="manualBagH" value="10" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Weight per bag:</label>
                        <input type="number" id="manualBagWeight" value="5" step="0.1">
                        <span class="unit">kg</span>
                    </div>
                </div>
            </div>
        </div>

        <button class="calculate-btn" id="calculateBtn" onclick="optimize()">Calculate Optimal Packaging</button>

        <div class="results-section" id="results">
            <div class="optimal-dimensions">
                <h3 id="bagDimensionsTitle">Optimal Bag Dimensions</h3>
                <div class="dim-grid">
                    <div class="dim-item">
                        <div class="label">Length</div>
                        <div class="dim-value" id="optimalL">-</div>
                        <div class="label">cm</div>
                    </div>
                    <div class="dim-item">
                        <div class="label">Width</div>
                        <div class="dim-value" id="optimalW">-</div>
                        <div class="label">cm</div>
                    </div>
                    <div class="dim-item">
                        <div class="label">Height</div>
                        <div class="dim-value" id="optimalH">-</div>
                        <div class="label">cm</div>
                    </div>
                </div>
            </div>

            <div class="results-grid">
                <div class="result-card primary">
                    <h4>Total Bags per Container</h4>
                    <div class="value" id="totalBags">-</div>
                    <div class="detail">Maximum capacity achieved</div>
                </div>
                <div class="result-card success">
                    <h4>Bags per Pallet</h4>
                    <div class="value" id="bagsPerPallet">-</div>
                    <div class="detail" id="palletConfig">-</div>
                </div>
                <div class="result-card">
                    <h4>Pallets per Container</h4>
                    <div class="value" id="palletsPerContainer">-</div>
                    <div class="detail" id="containerConfig">-</div>
                </div>
                <div class="result-card">
                    <h4>Total Weight</h4>
                    <div class="value" id="totalWeight">-</div>
                    <div class="detail">kg per container</div>
                </div>
            </div>

            <div class="visualization">
                <h3>Packaging Visualization</h3>
                <div class="viz-container">
                    <div class="viz-box">
                        <h4>Bags on Pallet</h4>
                        <canvas id="palletCanvas" width="400" height="400"></canvas>
                    </div>
                    <div class="viz-box">
                        <h4>Pallets in Container</h4>
                        <canvas id="containerCanvas" width="400" height="400"></canvas>
                    </div>
                </div>
            </div>

            <div class="viz-3d">
                <h3>3D Interactive View</h3>
                <div id="viewer3d"></div>
                <div class="explosion-control">
                    <label>
                        Explode View: <span class="explosion-value" id="explosionValue">0%</span>
                    </label>
                    <input type="range" min="0" max="100" value="0" class="explosion-slider" id="explosionSlider">
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleBagMode() {
            const mode = document.getElementById('bagMode').value;
            const optimizeFields = document.getElementById('optimizeFields');
            const manualFields = document.getElementById('manualFields');
            const button = document.getElementById('calculateBtn');

            if (mode === 'optimize') {
                optimizeFields.style.display = 'block';
                manualFields.style.display = 'none';
                button.textContent = 'Calculate Optimal Packaging';
            } else {
                optimizeFields.style.display = 'none';
                manualFields.style.display = 'block';
                button.textContent = 'Calculate with Manual Dimensions';
            }
        }

        function optimize() {
            const mode = document.getElementById('bagMode').value;

            if (mode === 'manual') {
                calculateManual();
            } else {
                calculateOptimized();
            }
        }

        function calculateManual() {
            const containerL = parseFloat(document.getElementById('containerL').value);
            const containerW = parseFloat(document.getElementById('containerW').value);
            const containerH = parseFloat(document.getElementById('containerH').value);

            const palletL = parseFloat(document.getElementById('palletL').value);
            const palletW = parseFloat(document.getElementById('palletW').value);
            const palletH = parseFloat(document.getElementById('palletH').value);

            const bagL = parseFloat(document.getElementById('manualBagL').value);
            const bagW = parseFloat(document.getElementById('manualBagW').value);
            const bagH = parseFloat(document.getElementById('manualBagH').value);
            const bagWeight = parseFloat(document.getElementById('manualBagWeight').value);

            // Calculate bags per pallet with alternating orientations
            const bagsX1 = Math.floor(palletL / bagL);
            const bagsY1 = Math.floor(palletW / bagW);
            const bagsPerLayer1 = bagsX1 * bagsY1;

            const bagsX2 = Math.floor(palletL / bagW);
            const bagsY2 = Math.floor(palletW / bagL);
            const bagsPerLayer2 = bagsX2 * bagsY2;

            const totalLayers = Math.floor(palletH / bagH);
            const layer1Count = Math.ceil(totalLayers / 2);
            const layer2Count = Math.floor(totalLayers / 2);
            const bagsPerPallet = (layer1Count * bagsPerLayer1) + (layer2Count * bagsPerLayer2);

            // Try both pallet orientations
            const palletOrientations = [
                { l: palletL, w: palletW, rotated: false },
                { l: palletW, w: palletL, rotated: true }
            ];

            let bestConfig = { totalBags: 0 };

            for (let palletOrient of palletOrientations) {
                const palletsX = Math.floor(containerL / palletOrient.l);
                const palletsY = Math.floor(containerW / palletOrient.w);
                const palletsZ = Math.floor(containerH / palletH);
                const palletsPerContainer = palletsX * palletsY * palletsZ;
                const totalBags = bagsPerPallet * palletsPerContainer;

                if (totalBags > bestConfig.totalBags) {
                    bestConfig = {
                        totalBags,
                        bagDims: { l: bagL, w: bagW, h: bagH },
                        bagsPerPallet,
                        palletsPerContainer,
                        bagLayout: {
                            orientation1: { x: bagsX1, y: bagsY1 },
                            orientation2: { x: bagsX2, y: bagsY2 },
                            totalLayers: totalLayers,
                            bagHeight: bagH
                        },
                        palletLayout: { x: palletsX, y: palletsY, z: palletsZ },
                        palletRotated: palletOrient.rotated,
                        palletDims: { l: palletOrient.l, w: palletOrient.w }
                    };
                }
            }

            document.getElementById('bagDimensionsTitle').textContent = 'Manual Bag Dimensions';
            displayResults(bestConfig, bagWeight);
            visualize(bestConfig, palletL, palletW, palletH, containerL, containerW, containerH);
            init3DViewer(bestConfig, palletL, palletW, palletH);
        }

        function calculateOptimized() {
            const containerL = parseFloat(document.getElementById('containerL').value);
            const containerW = parseFloat(document.getElementById('containerW').value);
            const containerH = parseFloat(document.getElementById('containerH').value);

            const palletL = parseFloat(document.getElementById('palletL').value);
            const palletW = parseFloat(document.getElementById('palletW').value);
            const palletH = parseFloat(document.getElementById('palletH').value);

            const bagWeight = parseFloat(document.getElementById('bagWeight').value);
            const density = parseFloat(document.getElementById('density').value);
            const minBagDim = parseFloat(document.getElementById('minBagDim').value);
            const maxBagDim = parseFloat(document.getElementById('maxBagDim').value);
            const searchStep = parseFloat(document.getElementById('searchStep').value);

            const bagVolume = (bagWeight / density) * 1000000;

            let bestConfig = {
                totalBags: 0,
                bagDims: { l: 0, w: 0, h: 0 },
                bagsPerPallet: 0,
                palletsPerContainer: 0,
                bagLayout: { orientation1: {x: 0, y: 0}, orientation2: {x: 0, y: 0}, totalLayers: 0, bagHeight: 0 },
                palletLayout: { x: 0, y: 0, z: 0 },
                palletRotated: false,
                palletDims: { l: 0, w: 0 }
            };

            const minDim = Math.max(minBagDim, 5);
            const maxDim = Math.min(maxBagDim, palletL, palletW, palletH);

            for (let l = minDim; l <= maxDim; l += searchStep) {
                for (let w = minDim; w <= maxDim; w += searchStep) {
                    const h = bagVolume / (l * w);

                    if (h < minDim || h > maxDim) continue;

                    // Try different bag orientations
                    const orientations = [
                        { l, w, h },
                        { l: l, w: h, h: w },
                        { l: w, w: l, h: h },
                        { l: w, w: h, h: l },
                        { l: h, w: l, h: w },
                        { l: h, w: w, h: l }
                    ];

                    for (let bagDim of orientations) {
                        // Check that all dimensions are within min/max bounds
                        if (bagDim.l < minBagDim || bagDim.l > maxBagDim ||
                            bagDim.w < minBagDim || bagDim.w > maxBagDim ||
                            bagDim.h < minBagDim || bagDim.h > maxBagDim) {
                            continue;
                        }

                        // Orientation 1: normal placement (bag.l along pallet.l, bag.w along pallet.w)
                        const bagsX1 = Math.floor(palletL / bagDim.l);
                        const bagsY1 = Math.floor(palletW / bagDim.w);
                        const bagsPerLayer1 = bagsX1 * bagsY1;

                        // Orientation 2: rotated 90 degrees (bag.l along pallet.w, bag.w along pallet.l)
                        const bagsX2 = Math.floor(palletL / bagDim.w);
                        const bagsY2 = Math.floor(palletW / bagDim.l);
                        const bagsPerLayer2 = bagsX2 * bagsY2;

                        if (bagsPerLayer1 === 0 || bagsPerLayer2 === 0) continue;

                        // Calculate how many layers fit vertically
                        const totalLayers = Math.floor(palletH / bagDim.h);
                        if (totalLayers === 0) continue;

                        // Calculate total bags with alternating orientations
                        const layer1Count = Math.ceil(totalLayers / 2);  // odd layers (1st, 3rd, 5th...)
                        const layer2Count = Math.floor(totalLayers / 2); // even layers (2nd, 4th, 6th...)
                        const bagsPerPallet = (layer1Count * bagsPerLayer1) + (layer2Count * bagsPerLayer2);

                        // Try both pallet orientations in container
                        const palletOrientations = [
                            { l: palletL, w: palletW, rotated: false },
                            { l: palletW, w: palletL, rotated: true }
                        ];

                        for (let palletOrient of palletOrientations) {
                            // Calculate pallets per container with this pallet orientation
                            const palletsX = Math.floor(containerL / palletOrient.l);
                            const palletsY = Math.floor(containerW / palletOrient.w);
                            const palletsZ = Math.floor(containerH / palletH);
                            const palletsPerContainer = palletsX * palletsY * palletsZ;

                            const totalBags = bagsPerPallet * palletsPerContainer;

                            if (totalBags > bestConfig.totalBags) {
                                bestConfig = {
                                    totalBags,
                                    bagDims: { ...bagDim },
                                    bagsPerPallet,
                                    palletsPerContainer,
                                    bagLayout: {
                                        orientation1: { x: bagsX1, y: bagsY1 },
                                        orientation2: { x: bagsX2, y: bagsY2 },
                                        totalLayers: totalLayers,
                                        bagHeight: bagDim.h
                                    },
                                    palletLayout: { x: palletsX, y: palletsY, z: palletsZ },
                                    palletRotated: palletOrient.rotated,
                                    palletDims: { l: palletOrient.l, w: palletOrient.w }
                                };
                            }
                        }
                    }
                }
            }

            document.getElementById('bagDimensionsTitle').textContent = 'Optimal Bag Dimensions';
            displayResults(bestConfig, bagWeight);
            visualize(bestConfig, palletL, palletW, palletH, containerL, containerW, containerH);
            init3DViewer(bestConfig, palletL, palletW, palletH);
        }

        function displayResults(config, bagWeight) {
            document.getElementById('optimalL').textContent = config.bagDims.l.toFixed(1);
            document.getElementById('optimalW').textContent = config.bagDims.w.toFixed(1);
            document.getElementById('optimalH').textContent = config.bagDims.h.toFixed(1);

            document.getElementById('totalBags').textContent = config.totalBags.toLocaleString();
            document.getElementById('bagsPerPallet').textContent = config.bagsPerPallet.toLocaleString();

            const layer1Count = Math.ceil(config.bagLayout.totalLayers / 2);
            const layer2Count = Math.floor(config.bagLayout.totalLayers / 2);
            document.getElementById('palletConfig').textContent =
                `${config.bagLayout.totalLayers} layers: ` +
                `${config.bagLayout.orientation1.x}×${config.bagLayout.orientation1.y} / ` +
                `${config.bagLayout.orientation2.x}×${config.bagLayout.orientation2.y} (alternating)`;

            document.getElementById('palletsPerContainer').textContent = config.palletsPerContainer.toLocaleString();
            const rotationNote = config.palletRotated ? ' (rotated 90°)' : '';
            document.getElementById('containerConfig').textContent =
                `${config.palletLayout.x} × ${config.palletLayout.y} × ${config.palletLayout.z} pallets${rotationNote}`;

            const totalWeight = config.totalBags * bagWeight;
            document.getElementById('totalWeight').textContent = totalWeight.toLocaleString();

            document.getElementById('results').classList.add('active');
        }

        function visualize(config, palletL, palletW, palletH, containerL, containerW, containerH) {
            // Use original pallet dimensions for bag visualization
            drawPalletView(config, palletL, palletW);
            // Use potentially rotated pallet dimensions for container visualization
            drawContainerView(config, config.palletDims.l, config.palletDims.w, palletH, containerL, containerW, containerH);
        }

        function drawPalletView(config, palletL, palletW) {
            const canvas = document.getElementById('palletCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            const padding = 40;
            const availableWidth = width - 2 * padding;
            const availableHeight = height - 2 * padding;

            const totalLayers = config.bagLayout.totalLayers;
            const depthFactor = 0.3;

            // Get actual bag dimensions from config
            const bagL = config.bagDims.l;  // bag length
            const bagW = config.bagDims.w;  // bag width

            // Calculate total visualization bounds including 3D depth
            // Use larger bag dimension for depth calculation
            const avgBagSize = Math.max(bagL, bagW);
            const totalVisWidth = palletL + (totalLayers - 1) * avgBagSize * depthFactor;
            const totalVisHeight = palletW + (totalLayers - 1) * avgBagSize * depthFactor * 0.5;

            // Calculate scale to fit in canvas while maintaining pallet aspect ratio
            const scaleX = availableWidth / totalVisWidth;
            const scaleY = availableHeight / totalVisHeight;
            const scale = Math.min(scaleX, scaleY);

            // Calculate depth offset in pixels
            const depthOffset = avgBagSize * scale * depthFactor;

            // Draw each layer from back to front
            for (let z = totalLayers - 1; z >= 0; z--) {
                // Determine orientation for this layer (odd layers = orientation1, even layers = orientation2)
                const isOrientation1 = (z % 2 === 0);
                const cols = isOrientation1 ? config.bagLayout.orientation1.x : config.bagLayout.orientation2.x;
                const rows = isOrientation1 ? config.bagLayout.orientation1.y : config.bagLayout.orientation2.y;

                // CRITICAL: Calculate actual bag dimensions for THIS orientation
                // Orientation 1: bag.l along pallet.l, bag.w along pallet.w
                // Orientation 2: bag.w along pallet.l, bag.l along pallet.w (rotated 90°)
                let bagWidthCm, bagHeightCm;
                if (isOrientation1) {
                    bagWidthCm = bagL;   // bag length goes along pallet length
                    bagHeightCm = bagW;  // bag width goes along pallet width
                } else {
                    bagWidthCm = bagW;   // bag width goes along pallet length (rotated!)
                    bagHeightCm = bagL;  // bag length goes along pallet width (rotated!)
                }

                // Convert to pixels
                const bagWidthPx = bagWidthCm * scale;
                const bagHeightPx = bagHeightCm * scale;

                const individualBagWidth = bagWidthPx * 0.85;
                const individualBagHeight = bagHeightPx * 0.85;

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const xPos = padding + x * bagWidthPx + z * depthOffset;
                        const yPos = padding + y * bagHeightPx + z * depthOffset * 0.5;

                        // Different color for different orientations
                        const hue = isOrientation1 ? ((z / totalLayers) * 60 + 200) : ((z / totalLayers) * 60 + 140);
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.strokeStyle = `hsl(${hue}, 70%, 40%)`;
                        ctx.lineWidth = 1;

                        ctx.fillRect(xPos, yPos, individualBagWidth, individualBagHeight);
                        ctx.strokeRect(xPos, yPos, individualBagWidth, individualBagHeight);

                        // Add a small indicator showing orientation
                        if (individualBagWidth > 15 && individualBagHeight > 15) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            if (isOrientation1) {
                                ctx.fillRect(xPos + 2, yPos + 2, individualBagWidth - 4, 3);
                            } else {
                                ctx.fillRect(xPos + 2, yPos + 2, 3, individualBagHeight - 4);
                            }
                        }
                    }
                }
            }

            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${config.bagsPerPallet} bags per pallet (alternating layers)`, width / 2, height - 10);
        }

        function drawContainerView(config, palletL, palletW, palletH, containerL, containerW, containerH) {
            const canvas = document.getElementById('containerCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            const padding = 40;
            const availableWidth = width - 2 * padding;
            const availableHeight = height - 2 * padding;

            const { x: cols, y: rows, z: layers } = config.palletLayout;

            const depthFactor = 0.4;

            // Calculate total visualization size including 3D depth effect
            const avgPalletSize = Math.max(palletL, palletW);
            const totalVisWidth = containerL + (layers - 1) * avgPalletSize * depthFactor;
            const totalVisHeight = containerW + (layers - 1) * avgPalletSize * depthFactor * 0.5;

            // Calculate scale to fit canvas while maintaining container aspect ratio
            const scaleX = availableWidth / totalVisWidth;
            const scaleY = availableHeight / totalVisHeight;
            const scale = Math.min(scaleX, scaleY);

            // Convert pallet dimensions to pixels using the uniform scale
            const palletWidthPx = palletL * scale;
            const palletHeightPx = palletW * scale;
            const depthOffset = avgPalletSize * scale * depthFactor;

            for (let z = layers - 1; z >= 0; z--) {
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const xPos = padding + x * palletWidthPx + z * depthOffset;
                        const yPos = padding + y * palletHeightPx + z * depthOffset * 0.5;

                        const hue = (z / layers) * 60 + 30;
                        ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                        ctx.strokeStyle = `hsl(${hue}, 80%, 30%)`;
                        ctx.lineWidth = 2;

                        ctx.fillRect(xPos, yPos, palletWidthPx * 0.85, palletHeightPx * 0.85);
                        ctx.strokeRect(xPos, yPos, palletWidthPx * 0.85, palletHeightPx * 0.85);

                        // Draw orientation indicator
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'center';
                        const label = config.palletRotated ? 'P↻' : 'P';
                        ctx.fillText(label, xPos + palletWidthPx * 0.425, yPos + palletHeightPx * 0.5);

                        // Add orientation line indicator
                        if (palletWidthPx > 20 && palletHeightPx > 20) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            if (config.palletRotated) {
                                // Draw vertical line for rotated
                                ctx.moveTo(xPos + palletWidthPx * 0.425, yPos + palletHeightPx * 0.15);
                                ctx.lineTo(xPos + palletWidthPx * 0.425, yPos + palletHeightPx * 0.35);
                            } else {
                                // Draw horizontal line for normal
                                ctx.moveTo(xPos + palletWidthPx * 0.15, yPos + palletHeightPx * 0.15);
                                ctx.lineTo(xPos + palletWidthPx * 0.35, yPos + palletHeightPx * 0.15);
                            }
                            ctx.stroke();
                        }
                    }
                }
            }

            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${config.palletsPerContainer} pallets per container`, width / 2, height - 10);
        }

        // 3D Visualization
        let scene, camera, renderer, controls, bagMeshes = [];
        let explosionFactor = 0;

        function init3DViewer(config, palletL, palletW, palletH) {
            // Clear previous scene
            const container = document.getElementById('viewer3d');
            container.innerHTML = '';
            bagMeshes = [];

            // Reset explosion slider
            document.getElementById('explosionSlider').value = 0;
            document.getElementById('explosionValue').textContent = '0%';
            explosionFactor = 0;

            // Setup scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Setup camera
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            camera = new THREE.PerspectiveCamera(45, containerWidth / containerHeight, 1, 10000);

            // Position camera to view the whole container
            const maxDim = Math.max(palletL * config.palletLayout.x,
                                   palletW * config.palletLayout.y,
                                   palletH * config.palletLayout.z);
            camera.position.set(maxDim * 1.5, maxDim * 1.2, maxDim * 1.5);
            camera.lookAt(0, 0, 0);

            // Setup renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            container.appendChild(renderer.domElement);

            // Setup orbit controls for mouse interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = maxDim * 0.5;
            controls.maxDistance = maxDim * 3;
            controls.maxPolarAngle = Math.PI;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight1.position.set(100, 100, 100);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-100, 50, -100);
            scene.add(directionalLight2);

            // Create container outline (wireframe)
            const containerDims = config.palletRotated ?
                [palletL * config.palletLayout.x, palletH * config.palletLayout.z, palletW * config.palletLayout.y] :
                [palletL * config.palletLayout.x, palletH * config.palletLayout.z, palletW * config.palletLayout.y];

            const containerGeometry = new THREE.BoxGeometry(containerDims[0], containerDims[1], containerDims[2]);
            const containerEdges = new THREE.EdgesGeometry(containerGeometry);
            const containerLine = new THREE.LineSegments(containerEdges, new THREE.LineBasicMaterial({ color: 0x667eea, linewidth: 2 }));
            scene.add(containerLine);

            // Calculate center of container
            const centerX = 0;
            const centerY = 0;
            const centerZ = 0;

            // Create bags
            const bagL = config.bagDims.l;
            const bagW = config.bagDims.w;
            const bagH = config.bagDims.h;

            // Get pallet dimensions (possibly rotated)
            const actualPalletL = config.palletDims.l;
            const actualPalletW = config.palletDims.w;

            // Starting positions
            const startX = -containerDims[0] / 2;
            const startY = -containerDims[1] / 2;
            const startZ = -containerDims[2] / 2;

            // Iterate through pallets
            for (let pz = 0; pz < config.palletLayout.z; pz++) {
                for (let py = 0; py < config.palletLayout.y; py++) {
                    for (let px = 0; px < config.palletLayout.x; px++) {
                        // Pallet base position
                        const palletX = startX + px * actualPalletL + actualPalletL / 2;
                        const palletY = startY + pz * palletH;
                        const palletZ = startZ + py * actualPalletW + actualPalletW / 2;

                        // Iterate through bag layers on this pallet
                        for (let layer = 0; layer < config.bagLayout.totalLayers; layer++) {
                            const isOrientation1 = (layer % 2 === 0);
                            const cols = isOrientation1 ? config.bagLayout.orientation1.x : config.bagLayout.orientation2.x;
                            const rows = isOrientation1 ? config.bagLayout.orientation1.y : config.bagLayout.orientation2.y;

                            // Determine bag dimensions for this orientation
                            let currentBagL, currentBagW;
                            if (isOrientation1) {
                                currentBagL = bagL;
                                currentBagW = bagW;
                            } else {
                                currentBagL = bagW;
                                currentBagW = bagL;
                            }

                            // Starting position for bags on this pallet
                            const bagStartX = palletX - actualPalletL / 2;
                            const bagStartZ = palletZ - actualPalletW / 2;

                            for (let by = 0; by < rows; by++) {
                                for (let bx = 0; bx < cols; bx++) {
                                    const bagX = bagStartX + bx * currentBagL + currentBagL / 2;
                                    const bagY = palletY + layer * bagH + bagH / 2;
                                    const bagZ = bagStartZ + by * currentBagW + currentBagW / 2;

                                    // Create bag mesh
                                    const geometry = new THREE.BoxGeometry(currentBagL, bagH, currentBagW);

                                    // Alternate colors for different orientations
                                    const hue = isOrientation1 ? 0.6 : 0.4;
                                    const color = new THREE.Color().setHSL(hue, 0.7, 0.5);

                                    const material = new THREE.MeshPhongMaterial({
                                        color: color,
                                        shininess: 30,
                                        transparent: true,
                                        opacity: 0.9
                                    });

                                    const mesh = new THREE.Mesh(geometry, material);

                                    // Store original position for explosion
                                    mesh.userData.originalPos = { x: bagX, y: bagY, z: bagZ };
                                    mesh.userData.centerOffset = {
                                        x: bagX - centerX,
                                        y: bagY - centerY,
                                        z: bagZ - centerZ
                                    };

                                    mesh.position.set(bagX, bagY, bagZ);

                                    // Add edge outline
                                    const edges = new THREE.EdgesGeometry(geometry);
                                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }));
                                    mesh.add(line);

                                    scene.add(mesh);
                                    bagMeshes.push(mesh);
                                }
                            }
                        }
                    }
                }
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Update controls for smooth damping
                controls.update();

                renderer.render(scene, camera);
            }
            animate();

            // Setup explosion slider
            const slider = document.getElementById('explosionSlider');
            const valueDisplay = document.getElementById('explosionValue');

            slider.oninput = function() {
                explosionFactor = this.value / 100;
                valueDisplay.textContent = this.value + '%';
                updateExplosion();
            };

            // Handle window resize
            window.addEventListener('resize', function() {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        }

        function updateExplosion() {
            bagMeshes.forEach(mesh => {
                const orig = mesh.userData.originalPos;
                const offset = mesh.userData.centerOffset;

                // Move bags away from center based on explosion factor
                mesh.position.x = orig.x + offset.x * explosionFactor * 2;
                mesh.position.y = orig.y + offset.y * explosionFactor * 2;
                mesh.position.z = orig.z + offset.z * explosionFactor * 2;
            });
        }

        // EPIC THEME MUSIC - ULTIMATE CHARCOAL MAXIMIZER ANTHEM!
        let audioContext;
        let musicPlaying = false;

        function playNote(freq, startTime, duration, type = 'sine', volume = 0.1, masterGain) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = type;
            osc.frequency.value = freq;

            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(volume, startTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            osc.connect(gain);
            gain.connect(masterGain);

            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        function playEpicTheme() {
            if (musicPlaying) return;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                musicPlaying = true;

                const masterGain = audioContext.createGain();
                masterGain.gain.value = 0.25;
                masterGain.connect(audioContext.destination);

                let time = audioContext.currentTime;
                const bpm = 140;
                const beat = 60 / bpm;

                // Catchy melody like an 80s game show theme
                // Pattern: "DA-DA-DA-DUM, DA-DA-DA-DAAA" (think Price is Right energy)
                const melody = [
                    // Bar 1: Ascending hook
                    { note: 523.25, time: 0, dur: beat * 0.4 },      // C5
                    { note: 587.33, time: beat * 0.5, dur: beat * 0.4 },  // D5
                    { note: 659.25, time: beat * 1, dur: beat * 0.4 },    // E5
                    { note: 783.99, time: beat * 1.5, dur: beat * 1.4 },  // G5 (hold)

                    // Bar 2: Response
                    { note: 659.25, time: beat * 3, dur: beat * 0.4 },    // E5
                    { note: 587.33, time: beat * 3.5, dur: beat * 0.4 },  // D5
                    { note: 523.25, time: beat * 4, dur: beat * 0.4 },    // C5
                    { note: 659.25, time: beat * 4.5, dur: beat * 1.4 },  // E5 (hold)

                    // Bar 3: Build up
                    { note: 698.46, time: beat * 6, dur: beat * 0.4 },    // F5
                    { note: 783.99, time: beat * 6.5, dur: beat * 0.4 },  // G5
                    { note: 880.00, time: beat * 7, dur: beat * 0.4 },    // A5
                    { note: 1046.50, time: beat * 7.5, dur: beat * 1.4 }, // C6 (climax!)

                    // Bar 4: Triumphant ending
                    { note: 783.99, time: beat * 9, dur: beat * 0.4 },    // G5
                    { note: 659.25, time: beat * 9.5, dur: beat * 0.4 },  // E5
                    { note: 523.25, time: beat * 10, dur: beat * 1.8 },   // C5 (long!)
                ];

                // Bass line (four-on-the-floor with variation)
                const bassPattern = [
                    // Bar 1-2: C root
                    { note: 130.81, time: 0, dur: beat * 0.8 },
                    { note: 130.81, time: beat * 1, dur: beat * 0.8 },
                    { note: 130.81, time: beat * 2, dur: beat * 0.8 },
                    { note: 130.81, time: beat * 3, dur: beat * 0.8 },
                    // Bar 3: F
                    { note: 174.61, time: beat * 4, dur: beat * 0.8 },
                    { note: 174.61, time: beat * 5, dur: beat * 0.8 },
                    // Bar 4: G
                    { note: 196.00, time: beat * 6, dur: beat * 0.8 },
                    { note: 196.00, time: beat * 7, dur: beat * 0.8 },
                    // Bar 5-6: Back to C
                    { note: 130.81, time: beat * 8, dur: beat * 0.8 },
                    { note: 130.81, time: beat * 9, dur: beat * 0.8 },
                    { note: 130.81, time: beat * 10, dur: beat * 0.8 },
                    { note: 130.81, time: beat * 11, dur: beat * 0.8 },
                ];

                // Harmony chords (bright and uplifting)
                const chords = [
                    // C major
                    { notes: [261.63, 329.63, 392.00], time: 0, dur: beat * 4 },
                    // F major
                    { notes: [174.61, 220.00, 261.63], time: beat * 4, dur: beat * 2 },
                    // G major
                    { notes: [196.00, 246.94, 293.66], time: beat * 6, dur: beat * 2 },
                    // C major (resolution)
                    { notes: [261.63, 329.63, 392.00], time: beat * 8, dur: beat * 4 },
                ];

                // Play melody (lead synth - bright!)
                melody.forEach(m => {
                    playNote(m.note, time + m.time, m.dur, 'square', 0.15, masterGain);
                    // Add slight vibrato/chorus effect
                    playNote(m.note * 1.01, time + m.time, m.dur, 'square', 0.08, masterGain);
                });

                // Play bass (warm and punchy)
                bassPattern.forEach(b => {
                    playNote(b.note, time + b.time, b.dur, 'triangle', 0.3, masterGain);
                });

                // Play chords (pad sound)
                chords.forEach(c => {
                    c.notes.forEach(note => {
                        playNote(note, time + c.time, c.dur, 'sawtooth', 0.08, masterGain);
                    });
                });

                // Add rhythmic synth stabs on beats 2 and 4
                for (let i = 1; i < 12; i += 2) {
                    playNote(1046.50, time + i * beat, beat * 0.1, 'square', 0.12, masterGain);
                }

                // Kick drum on every beat
                for (let i = 0; i < 12; i++) {
                    const kick = audioContext.createOscillator();
                    const kickGain = audioContext.createGain();

                    kick.frequency.setValueAtTime(150, time + i * beat);
                    kick.frequency.exponentialRampToValueAtTime(0.01, time + i * beat + 0.15);

                    kickGain.gain.setValueAtTime(0.4, time + i * beat);
                    kickGain.gain.exponentialRampToValueAtTime(0.001, time + i * beat + 0.15);

                    kick.connect(kickGain);
                    kickGain.connect(masterGain);

                    kick.start(time + i * beat);
                    kick.stop(time + i * beat + 0.15);
                }

                // Hi-hats (16th notes for energy)
                for (let i = 0; i < 48; i++) {
                    const hihat = audioContext.createOscillator();
                    const hihatGain = audioContext.createGain();

                    hihat.type = 'square';
                    hihat.frequency.value = 8000 + Math.random() * 2000;

                    const vol = (i % 4 === 0) ? 0.04 : 0.02; // Accent every 4th
                    hihatGain.gain.setValueAtTime(vol, time + i * beat * 0.25);
                    hihatGain.gain.exponentialRampToValueAtTime(0.001, time + i * beat * 0.25 + 0.05);

                    hihat.connect(hihatGain);
                    hihatGain.connect(masterGain);

                    hihat.start(time + i * beat * 0.25);
                    hihat.stop(time + i * beat * 0.25 + 0.05);
                }

                // Loop seamlessly
                const totalDuration = beat * 12;
                setTimeout(() => {
                    musicPlaying = false;
                    playEpicTheme();
                }, (totalDuration * 1000) - 50);

            } catch (e) {
                console.log('Audio not available:', e);
            }
        }

        // Auto-play on load
        window.addEventListener('load', () => {
            playEpicTheme();
        });

        // Fallback on first click
        document.addEventListener('click', () => {
            if (!musicPlaying) {
                playEpicTheme();
            }
        }, { once: true });
    </script>
</body>
</html>
