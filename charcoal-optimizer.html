<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Charcoal Bag Packaging Optimizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .input-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .input-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .input-group h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .input-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .input-row label {
            flex: 1;
            color: #495057;
            font-weight: 500;
        }

        .input-row input {
            width: 100px;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }

        .input-row input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .unit {
            margin-left: 8px;
            color: #6c757d;
            font-size: 13px;
        }

        .calculate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 30px;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .calculate-btn:active {
            transform: translateY(0);
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .result-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 20px;
            border-radius: 10px;
            color: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-card.primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .result-card.success {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .result-card h4 {
            font-size: 14px;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .result-card .value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .result-card .detail {
            font-size: 13px;
            opacity: 0.9;
        }

        .visualization {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .visualization h3 {
            color: #495057;
            margin-bottom: 15px;
        }

        .viz-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .viz-box {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .viz-box h4 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 16px;
        }

        canvas {
            width: 100%;
            border-radius: 5px;
            background: #fff;
        }

        .optimal-dimensions {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .optimal-dimensions h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .dim-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .dim-item {
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 8px;
        }

        .dim-item .label {
            color: #856404;
            font-size: 13px;
            margin-bottom: 5px;
        }

        .dim-item .dim-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .viz-3d {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .viz-3d h3 {
            color: #495057;
            margin-bottom: 15px;
        }

        #viewer3d {
            width: 100%;
            height: 600px;
            background: #1a1a2e;
            border-radius: 8px;
            position: relative;
        }

        .explosion-control {
            margin-top: 15px;
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .explosion-control label {
            display: block;
            color: #495057;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .explosion-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e9ecef;
            outline: none;
            -webkit-appearance: none;
        }

        .explosion-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
        }

        .explosion-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
        }

        .explosion-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #667eea;
        }

        .hero-header {
            background: linear-gradient(135deg, #ff6b6b 0%, #feca57 25%, #48dbfb 50%, #ff9ff3 75%, #ff6b6b 100%);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 15px 40px rgba(255, 107, 107, 0.4);
            text-align: center;
            border: 5px solid #ffd700;
            position: relative;
            overflow: hidden;
        }

        .hero-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .hero-title {
            font-size: 56px;
            font-weight: 900;
            color: #fff;
            text-shadow:
                4px 4px 0px #000,
                6px 6px 10px rgba(0,0,0,0.5),
                0 0 20px rgba(255,215,0,0.8);
            margin: 0;
            letter-spacing: 2px;
            animation: pulse 2s ease-in-out infinite;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
        }

        .hero-subtitle {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255,215,0,0.6);
            margin: 15px 0 0 0;
            position: relative;
            z-index: 1;
        }

        .hero-tagline {
            font-size: 18px;
            color: #ffe066;
            text-shadow: 2px 2px 3px #000;
            margin: 10px 0 0 0;
            font-style: italic;
            position: relative;
            z-index: 1;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .badge {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #000;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);
            border: 2px solid #ff6b6b;
            animation: pulse 2s ease-in-out infinite;
        }

        .badge:nth-child(2) {
            animation-delay: 0.3s;
        }

        .badge:nth-child(3) {
            animation-delay: 0.6s;
        }

        .badge:nth-child(4) {
            animation-delay: 0.9s;
        }

        .music-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            flex-direction: column;
            align-items: flex-end;
        }

        .music-toggle {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            border: 3px solid #ff6b6b;
            border-radius: 50px;
            padding: 12px 24px;
            font-weight: bold;
            font-size: 16px;
            color: #000;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .music-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.8);
        }

        .music-toggle:active {
            transform: scale(0.95);
        }

        .music-toggle.muted {
            background: linear-gradient(135deg, #999 0%, #666 100%);
            border-color: #333;
        }

        .music-icon {
            font-size: 20px;
        }

        .music-selector {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid #ffd700;
            border-radius: 25px;
            padding: 10px 20px;
            font-weight: bold;
            font-size: 14px;
            color: white;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            transition: all 0.3s ease;
        }

        .music-selector:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="music-controls">
        <select class="music-selector" id="musicSelector" onchange="changeSong()">
            <option value="happy">ðŸŽ‰ Happy Song</option>
            <option value="sad">ðŸ˜¢ Sad Song</option>
            <option value="metal">ðŸ¤˜ Thrash Metal</option>
            <option value="synthwave">ðŸŒ† Synthwave</option>
        </select>
        <button class="music-toggle" id="musicToggle" onclick="toggleMusic()">
            <span class="music-icon">ðŸ”Š</span>
            <span id="musicStatus">Music ON</span>
        </button>
    </div>

    <div class="container">
        <div class="hero-header">
            <h1 class="hero-title">ULTIMATE CHARCOAL PACKING MAXIMIZER 3000!</h1>
            <p class="hero-subtitle">PACK MORE! EARN MORE! SAVE MORE!</p>
            <p class="hero-tagline">"The SECRET WEAPON Every Charcoal Producer Has Been WAITING FOR!"</p>
            <div class="badges">
                <span class="badge">100% GUARANTEED RESULTS!</span>
                <span class="badge">REVOLUTIONARY 3D TECHNOLOGY!</span>
                <span class="badge">AI-POWERED OPTIMIZATION!</span>
                <span class="badge">INSTANT CALCULATIONS!</span>
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <h3>Container Dimensions</h3>
                <div class="input-row">
                    <label>Length:</label>
                    <input type="number" id="containerL" value="1200" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Width:</label>
                    <input type="number" id="containerW" value="235" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Height:</label>
                    <input type="number" id="containerH" value="239" step="1">
                    <span class="unit">cm</span>
                </div>
            </div>

            <div class="input-group">
                <h3>Pallet Dimensions</h3>
                <div class="input-row">
                    <label>Length:</label>
                    <input type="number" id="palletL" value="120" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Width:</label>
                    <input type="number" id="palletW" value="80" step="1">
                    <span class="unit">cm</span>
                </div>
                <div class="input-row">
                    <label>Height (max):</label>
                    <input type="number" id="palletH" value="120" step="1">
                    <span class="unit">cm</span>
                </div>
            </div>

            <div class="input-group">
                <h3>Bag Specifications</h3>
                <div class="input-row">
                    <label>Mode:</label>
                    <select id="bagMode" onchange="toggleBagMode()" style="width: 150px; padding: 8px; border: 1px solid #ced4da; border-radius: 5px;">
                        <option value="optimize">Optimize</option>
                        <option value="manual">Manual Override</option>
                    </select>
                </div>

                <div id="optimizeFields">
                    <div class="input-row">
                        <label>Weight per bag:</label>
                        <input type="number" id="bagWeight" value="5" step="0.1">
                        <span class="unit">kg</span>
                    </div>
                    <div class="input-row">
                        <label>Charcoal density:</label>
                        <input type="number" id="density" value="300" step="1">
                        <span class="unit">kg/mÂ³</span>
                    </div>
                    <div class="input-row">
                        <label>Min bag dimension:</label>
                        <input type="number" id="minBagDim" value="10" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Max bag dimension:</label>
                        <input type="number" id="maxBagDim" value="60" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Search step:</label>
                        <input type="number" id="searchStep" value="1" step="0.5" min="0.5">
                        <span class="unit">cm</span>
                    </div>
                </div>

                <div id="manualFields" style="display: none;">
                    <div class="input-row">
                        <label>Bag length:</label>
                        <input type="number" id="manualBagL" value="30" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Bag width:</label>
                        <input type="number" id="manualBagW" value="20" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Bag height:</label>
                        <input type="number" id="manualBagH" value="10" step="1">
                        <span class="unit">cm</span>
                    </div>
                    <div class="input-row">
                        <label>Weight per bag:</label>
                        <input type="number" id="manualBagWeight" value="5" step="0.1">
                        <span class="unit">kg</span>
                    </div>
                </div>
            </div>
        </div>

        <button class="calculate-btn" id="calculateBtn" onclick="optimize()">Calculate Optimal Packaging</button>

        <div class="results-section" id="results">
            <div class="optimal-dimensions">
                <h3 id="bagDimensionsTitle">Optimal Bag Dimensions</h3>
                <div class="dim-grid">
                    <div class="dim-item">
                        <div class="label">Length</div>
                        <div class="dim-value" id="optimalL">-</div>
                        <div class="label">cm</div>
                    </div>
                    <div class="dim-item">
                        <div class="label">Width</div>
                        <div class="dim-value" id="optimalW">-</div>
                        <div class="label">cm</div>
                    </div>
                    <div class="dim-item">
                        <div class="label">Height</div>
                        <div class="dim-value" id="optimalH">-</div>
                        <div class="label">cm</div>
                    </div>
                </div>
            </div>

            <div class="results-grid">
                <div class="result-card primary">
                    <h4>Total Bags per Container</h4>
                    <div class="value" id="totalBags">-</div>
                    <div class="detail">Maximum capacity achieved</div>
                </div>
                <div class="result-card success">
                    <h4>Bags per Pallet</h4>
                    <div class="value" id="bagsPerPallet">-</div>
                    <div class="detail" id="palletConfig">-</div>
                </div>
                <div class="result-card">
                    <h4>Pallets per Container</h4>
                    <div class="value" id="palletsPerContainer">-</div>
                    <div class="detail" id="containerConfig">-</div>
                </div>
                <div class="result-card">
                    <h4>Total Weight</h4>
                    <div class="value" id="totalWeight">-</div>
                    <div class="detail">kg per container</div>
                </div>
            </div>

            <div class="visualization">
                <h3>Packaging Visualization</h3>
                <div class="viz-container">
                    <div class="viz-box">
                        <h4>Bags on Pallet</h4>
                        <canvas id="palletCanvas" width="400" height="400"></canvas>
                    </div>
                    <div class="viz-box">
                        <h4>Pallets in Container</h4>
                        <canvas id="containerCanvas" width="400" height="400"></canvas>
                    </div>
                </div>
            </div>

            <div class="viz-3d">
                <h3>3D Interactive View</h3>
                <div id="viewer3d"></div>
                <div class="explosion-control">
                    <label>
                        Explode View: <span class="explosion-value" id="explosionValue">0%</span>
                    </label>
                    <input type="range" min="0" max="100" value="0" class="explosion-slider" id="explosionSlider">
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleBagMode() {
            const mode = document.getElementById('bagMode').value;
            const optimizeFields = document.getElementById('optimizeFields');
            const manualFields = document.getElementById('manualFields');
            const button = document.getElementById('calculateBtn');

            if (mode === 'optimize') {
                optimizeFields.style.display = 'block';
                manualFields.style.display = 'none';
                button.textContent = 'Calculate Optimal Packaging';
            } else {
                optimizeFields.style.display = 'none';
                manualFields.style.display = 'block';
                button.textContent = 'Calculate with Manual Dimensions';
            }
        }

        function optimize() {
            const mode = document.getElementById('bagMode').value;

            if (mode === 'manual') {
                calculateManual();
            } else {
                calculateOptimized();
            }
        }

        function calculateManual() {
            const containerL = parseFloat(document.getElementById('containerL').value);
            const containerW = parseFloat(document.getElementById('containerW').value);
            const containerH = parseFloat(document.getElementById('containerH').value);

            const palletL = parseFloat(document.getElementById('palletL').value);
            const palletW = parseFloat(document.getElementById('palletW').value);
            const palletH = parseFloat(document.getElementById('palletH').value);

            const bagL = parseFloat(document.getElementById('manualBagL').value);
            const bagW = parseFloat(document.getElementById('manualBagW').value);
            const bagH = parseFloat(document.getElementById('manualBagH').value);
            const bagWeight = parseFloat(document.getElementById('manualBagWeight').value);

            // Calculate bags per pallet with alternating orientations
            const bagsX1 = Math.floor(palletL / bagL);
            const bagsY1 = Math.floor(palletW / bagW);
            const bagsPerLayer1 = bagsX1 * bagsY1;

            const bagsX2 = Math.floor(palletL / bagW);
            const bagsY2 = Math.floor(palletW / bagL);
            const bagsPerLayer2 = bagsX2 * bagsY2;

            const totalLayers = Math.floor(palletH / bagH);
            const layer1Count = Math.ceil(totalLayers / 2);
            const layer2Count = Math.floor(totalLayers / 2);
            const bagsPerPallet = (layer1Count * bagsPerLayer1) + (layer2Count * bagsPerLayer2);

            // Try both pallet orientations
            const palletOrientations = [
                { l: palletL, w: palletW, rotated: false },
                { l: palletW, w: palletL, rotated: true }
            ];

            let bestConfig = { totalBags: 0 };

            for (let palletOrient of palletOrientations) {
                const palletsX = Math.floor(containerL / palletOrient.l);
                const palletsY = Math.floor(containerW / palletOrient.w);
                const palletsZ = Math.floor(containerH / palletH);
                const palletsPerContainer = palletsX * palletsY * palletsZ;
                const totalBags = bagsPerPallet * palletsPerContainer;

                if (totalBags > bestConfig.totalBags) {
                    bestConfig = {
                        totalBags,
                        bagDims: { l: bagL, w: bagW, h: bagH },
                        bagsPerPallet,
                        palletsPerContainer,
                        bagLayout: {
                            orientation1: { x: bagsX1, y: bagsY1 },
                            orientation2: { x: bagsX2, y: bagsY2 },
                            totalLayers: totalLayers,
                            bagHeight: bagH
                        },
                        palletLayout: { x: palletsX, y: palletsY, z: palletsZ },
                        palletRotated: palletOrient.rotated,
                        palletDims: { l: palletOrient.l, w: palletOrient.w }
                    };
                }
            }

            document.getElementById('bagDimensionsTitle').textContent = 'Manual Bag Dimensions';
            displayResults(bestConfig, bagWeight);
            visualize(bestConfig, palletL, palletW, palletH, containerL, containerW, containerH);
            init3DViewer(bestConfig, palletL, palletW, palletH);
        }

        function calculateOptimized() {
            const containerL = parseFloat(document.getElementById('containerL').value);
            const containerW = parseFloat(document.getElementById('containerW').value);
            const containerH = parseFloat(document.getElementById('containerH').value);

            const palletL = parseFloat(document.getElementById('palletL').value);
            const palletW = parseFloat(document.getElementById('palletW').value);
            const palletH = parseFloat(document.getElementById('palletH').value);

            const bagWeight = parseFloat(document.getElementById('bagWeight').value);
            const density = parseFloat(document.getElementById('density').value);
            const minBagDim = parseFloat(document.getElementById('minBagDim').value);
            const maxBagDim = parseFloat(document.getElementById('maxBagDim').value);
            const searchStep = parseFloat(document.getElementById('searchStep').value);

            const bagVolume = (bagWeight / density) * 1000000;

            let bestConfig = {
                totalBags: 0,
                bagDims: { l: 0, w: 0, h: 0 },
                bagsPerPallet: 0,
                palletsPerContainer: 0,
                bagLayout: { orientation1: {x: 0, y: 0}, orientation2: {x: 0, y: 0}, totalLayers: 0, bagHeight: 0 },
                palletLayout: { x: 0, y: 0, z: 0 },
                palletRotated: false,
                palletDims: { l: 0, w: 0 }
            };

            const minDim = Math.max(minBagDim, 5);
            const maxDim = Math.min(maxBagDim, palletL, palletW, palletH);

            for (let l = minDim; l <= maxDim; l += searchStep) {
                for (let w = minDim; w <= maxDim; w += searchStep) {
                    const h = bagVolume / (l * w);

                    if (h < minDim || h > maxDim) continue;

                    // Try different bag orientations
                    const orientations = [
                        { l, w, h },
                        { l: l, w: h, h: w },
                        { l: w, w: l, h: h },
                        { l: w, w: h, h: l },
                        { l: h, w: l, h: w },
                        { l: h, w: w, h: l }
                    ];

                    for (let bagDim of orientations) {
                        // Check that all dimensions are within min/max bounds
                        if (bagDim.l < minBagDim || bagDim.l > maxBagDim ||
                            bagDim.w < minBagDim || bagDim.w > maxBagDim ||
                            bagDim.h < minBagDim || bagDim.h > maxBagDim) {
                            continue;
                        }

                        // Orientation 1: normal placement (bag.l along pallet.l, bag.w along pallet.w)
                        const bagsX1 = Math.floor(palletL / bagDim.l);
                        const bagsY1 = Math.floor(palletW / bagDim.w);
                        const bagsPerLayer1 = bagsX1 * bagsY1;

                        // Orientation 2: rotated 90 degrees (bag.l along pallet.w, bag.w along pallet.l)
                        const bagsX2 = Math.floor(palletL / bagDim.w);
                        const bagsY2 = Math.floor(palletW / bagDim.l);
                        const bagsPerLayer2 = bagsX2 * bagsY2;

                        if (bagsPerLayer1 === 0 || bagsPerLayer2 === 0) continue;

                        // Calculate how many layers fit vertically
                        const totalLayers = Math.floor(palletH / bagDim.h);
                        if (totalLayers === 0) continue;

                        // Calculate total bags with alternating orientations
                        const layer1Count = Math.ceil(totalLayers / 2);  // odd layers (1st, 3rd, 5th...)
                        const layer2Count = Math.floor(totalLayers / 2); // even layers (2nd, 4th, 6th...)
                        const bagsPerPallet = (layer1Count * bagsPerLayer1) + (layer2Count * bagsPerLayer2);

                        // Try both pallet orientations in container
                        const palletOrientations = [
                            { l: palletL, w: palletW, rotated: false },
                            { l: palletW, w: palletL, rotated: true }
                        ];

                        for (let palletOrient of palletOrientations) {
                            // Calculate pallets per container with this pallet orientation
                            const palletsX = Math.floor(containerL / palletOrient.l);
                            const palletsY = Math.floor(containerW / palletOrient.w);
                            const palletsZ = Math.floor(containerH / palletH);
                            const palletsPerContainer = palletsX * palletsY * palletsZ;

                            const totalBags = bagsPerPallet * palletsPerContainer;

                            if (totalBags > bestConfig.totalBags) {
                                bestConfig = {
                                    totalBags,
                                    bagDims: { ...bagDim },
                                    bagsPerPallet,
                                    palletsPerContainer,
                                    bagLayout: {
                                        orientation1: { x: bagsX1, y: bagsY1 },
                                        orientation2: { x: bagsX2, y: bagsY2 },
                                        totalLayers: totalLayers,
                                        bagHeight: bagDim.h
                                    },
                                    palletLayout: { x: palletsX, y: palletsY, z: palletsZ },
                                    palletRotated: palletOrient.rotated,
                                    palletDims: { l: palletOrient.l, w: palletOrient.w }
                                };
                            }
                        }
                    }
                }
            }

            document.getElementById('bagDimensionsTitle').textContent = 'Optimal Bag Dimensions';
            displayResults(bestConfig, bagWeight);
            visualize(bestConfig, palletL, palletW, palletH, containerL, containerW, containerH);
            init3DViewer(bestConfig, palletL, palletW, palletH);
        }

        function displayResults(config, bagWeight) {
            document.getElementById('optimalL').textContent = config.bagDims.l.toFixed(1);
            document.getElementById('optimalW').textContent = config.bagDims.w.toFixed(1);
            document.getElementById('optimalH').textContent = config.bagDims.h.toFixed(1);

            document.getElementById('totalBags').textContent = config.totalBags.toLocaleString();
            document.getElementById('bagsPerPallet').textContent = config.bagsPerPallet.toLocaleString();

            const layer1Count = Math.ceil(config.bagLayout.totalLayers / 2);
            const layer2Count = Math.floor(config.bagLayout.totalLayers / 2);
            document.getElementById('palletConfig').textContent =
                `${config.bagLayout.totalLayers} layers: ` +
                `${config.bagLayout.orientation1.x}Ã—${config.bagLayout.orientation1.y} / ` +
                `${config.bagLayout.orientation2.x}Ã—${config.bagLayout.orientation2.y} (alternating)`;

            document.getElementById('palletsPerContainer').textContent = config.palletsPerContainer.toLocaleString();
            const rotationNote = config.palletRotated ? ' (rotated 90Â°)' : '';
            document.getElementById('containerConfig').textContent =
                `${config.palletLayout.x} Ã— ${config.palletLayout.y} Ã— ${config.palletLayout.z} pallets${rotationNote}`;

            const totalWeight = config.totalBags * bagWeight;
            document.getElementById('totalWeight').textContent = totalWeight.toLocaleString();

            document.getElementById('results').classList.add('active');
        }

        function visualize(config, palletL, palletW, palletH, containerL, containerW, containerH) {
            // Use original pallet dimensions for bag visualization
            drawPalletView(config, palletL, palletW);
            // Use potentially rotated pallet dimensions for container visualization
            drawContainerView(config, config.palletDims.l, config.palletDims.w, palletH, containerL, containerW, containerH);
        }

        function drawPalletView(config, palletL, palletW) {
            const canvas = document.getElementById('palletCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            const padding = 40;
            const availableWidth = width - 2 * padding;
            const availableHeight = height - 2 * padding;

            const totalLayers = config.bagLayout.totalLayers;
            const depthFactor = 0.3;

            // Get actual bag dimensions from config
            const bagL = config.bagDims.l;  // bag length
            const bagW = config.bagDims.w;  // bag width

            // Calculate total visualization bounds including 3D depth
            // Use larger bag dimension for depth calculation
            const avgBagSize = Math.max(bagL, bagW);
            const totalVisWidth = palletL + (totalLayers - 1) * avgBagSize * depthFactor;
            const totalVisHeight = palletW + (totalLayers - 1) * avgBagSize * depthFactor * 0.5;

            // Calculate scale to fit in canvas while maintaining pallet aspect ratio
            const scaleX = availableWidth / totalVisWidth;
            const scaleY = availableHeight / totalVisHeight;
            const scale = Math.min(scaleX, scaleY);

            // Calculate depth offset in pixels
            const depthOffset = avgBagSize * scale * depthFactor;

            // Draw each layer from back to front
            for (let z = totalLayers - 1; z >= 0; z--) {
                // Determine orientation for this layer (odd layers = orientation1, even layers = orientation2)
                const isOrientation1 = (z % 2 === 0);
                const cols = isOrientation1 ? config.bagLayout.orientation1.x : config.bagLayout.orientation2.x;
                const rows = isOrientation1 ? config.bagLayout.orientation1.y : config.bagLayout.orientation2.y;

                // CRITICAL: Calculate actual bag dimensions for THIS orientation
                // Orientation 1: bag.l along pallet.l, bag.w along pallet.w
                // Orientation 2: bag.w along pallet.l, bag.l along pallet.w (rotated 90Â°)
                let bagWidthCm, bagHeightCm;
                if (isOrientation1) {
                    bagWidthCm = bagL;   // bag length goes along pallet length
                    bagHeightCm = bagW;  // bag width goes along pallet width
                } else {
                    bagWidthCm = bagW;   // bag width goes along pallet length (rotated!)
                    bagHeightCm = bagL;  // bag length goes along pallet width (rotated!)
                }

                // Convert to pixels
                const bagWidthPx = bagWidthCm * scale;
                const bagHeightPx = bagHeightCm * scale;

                const individualBagWidth = bagWidthPx * 0.85;
                const individualBagHeight = bagHeightPx * 0.85;

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const xPos = padding + x * bagWidthPx + z * depthOffset;
                        const yPos = padding + y * bagHeightPx + z * depthOffset * 0.5;

                        // Different color for different orientations
                        const hue = isOrientation1 ? ((z / totalLayers) * 60 + 200) : ((z / totalLayers) * 60 + 140);
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.strokeStyle = `hsl(${hue}, 70%, 40%)`;
                        ctx.lineWidth = 1;

                        ctx.fillRect(xPos, yPos, individualBagWidth, individualBagHeight);
                        ctx.strokeRect(xPos, yPos, individualBagWidth, individualBagHeight);

                        // Add a small indicator showing orientation
                        if (individualBagWidth > 15 && individualBagHeight > 15) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            if (isOrientation1) {
                                ctx.fillRect(xPos + 2, yPos + 2, individualBagWidth - 4, 3);
                            } else {
                                ctx.fillRect(xPos + 2, yPos + 2, 3, individualBagHeight - 4);
                            }
                        }
                    }
                }
            }

            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${config.bagsPerPallet} bags per pallet (alternating layers)`, width / 2, height - 10);
        }

        function drawContainerView(config, palletL, palletW, palletH, containerL, containerW, containerH) {
            const canvas = document.getElementById('containerCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            const padding = 40;
            const availableWidth = width - 2 * padding;
            const availableHeight = height - 2 * padding;

            const { x: cols, y: rows, z: layers } = config.palletLayout;

            const depthFactor = 0.4;

            // Calculate total visualization size including 3D depth effect
            const avgPalletSize = Math.max(palletL, palletW);
            const totalVisWidth = containerL + (layers - 1) * avgPalletSize * depthFactor;
            const totalVisHeight = containerW + (layers - 1) * avgPalletSize * depthFactor * 0.5;

            // Calculate scale to fit canvas while maintaining container aspect ratio
            const scaleX = availableWidth / totalVisWidth;
            const scaleY = availableHeight / totalVisHeight;
            const scale = Math.min(scaleX, scaleY);

            // Convert pallet dimensions to pixels using the uniform scale
            const palletWidthPx = palletL * scale;
            const palletHeightPx = palletW * scale;
            const depthOffset = avgPalletSize * scale * depthFactor;

            for (let z = layers - 1; z >= 0; z--) {
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const xPos = padding + x * palletWidthPx + z * depthOffset;
                        const yPos = padding + y * palletHeightPx + z * depthOffset * 0.5;

                        const hue = (z / layers) * 60 + 30;
                        ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                        ctx.strokeStyle = `hsl(${hue}, 80%, 30%)`;
                        ctx.lineWidth = 2;

                        ctx.fillRect(xPos, yPos, palletWidthPx * 0.85, palletHeightPx * 0.85);
                        ctx.strokeRect(xPos, yPos, palletWidthPx * 0.85, palletHeightPx * 0.85);

                        // Draw orientation indicator
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'center';
                        const label = config.palletRotated ? 'Pâ†»' : 'P';
                        ctx.fillText(label, xPos + palletWidthPx * 0.425, yPos + palletHeightPx * 0.5);

                        // Add orientation line indicator
                        if (palletWidthPx > 20 && palletHeightPx > 20) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            if (config.palletRotated) {
                                // Draw vertical line for rotated
                                ctx.moveTo(xPos + palletWidthPx * 0.425, yPos + palletHeightPx * 0.15);
                                ctx.lineTo(xPos + palletWidthPx * 0.425, yPos + palletHeightPx * 0.35);
                            } else {
                                // Draw horizontal line for normal
                                ctx.moveTo(xPos + palletWidthPx * 0.15, yPos + palletHeightPx * 0.15);
                                ctx.lineTo(xPos + palletWidthPx * 0.35, yPos + palletHeightPx * 0.15);
                            }
                            ctx.stroke();
                        }
                    }
                }
            }

            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${config.palletsPerContainer} pallets per container`, width / 2, height - 10);
        }

        // 3D Visualization
        let scene, camera, renderer, controls, bagMeshes = [];
        let explosionFactor = 0;

        function init3DViewer(config, palletL, palletW, palletH) {
            // Clear previous scene
            const container = document.getElementById('viewer3d');
            container.innerHTML = '';
            bagMeshes = [];

            // Reset explosion slider
            document.getElementById('explosionSlider').value = 0;
            document.getElementById('explosionValue').textContent = '0%';
            explosionFactor = 0;

            // Setup scene
            scene = new THREE.Scene();

            // Create factory background with gradient sky
            const skyColor = new THREE.Color(0x87CEEB);
            const groundColor = new THREE.Color(0x3a3a3a);
            scene.background = skyColor;
            scene.fog = new THREE.Fog(skyColor, 2000, 5000);

            // Setup camera
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            camera = new THREE.PerspectiveCamera(45, containerWidth / containerHeight, 1, 10000);

            // Position camera to view the whole container
            const maxDim = Math.max(palletL * config.palletLayout.x,
                                   palletW * config.palletLayout.y,
                                   palletH * config.palletLayout.z);
            camera.position.set(maxDim * 1.5, maxDim * 1.2, maxDim * 1.5);
            camera.lookAt(0, 0, 0);

            // Setup renderer with shadows
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Setup orbit controls for mouse interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = maxDim * 0.5;
            controls.maxDistance = maxDim * 3;
            controls.maxPolarAngle = Math.PI / 1.8;

            // Add realistic lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffee, 0.8);
            sunLight.position.set(maxDim * 2, maxDim * 3, maxDim * 2);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.far = maxDim * 10;
            scene.add(sunLight);

            const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
            fillLight.position.set(-maxDim, maxDim * 0.5, -maxDim);
            scene.add(fillLight);

            // Create container dimensions first (needed for ground positioning)
            const containerDims = config.palletRotated ?
                [palletL * config.palletLayout.x, palletH * config.palletLayout.z, palletW * config.palletLayout.y] :
                [palletL * config.palletLayout.x, palletH * config.palletLayout.z, palletW * config.palletLayout.y];

            // Add ground plane (factory floor)
            const groundGeometry = new THREE.PlaneGeometry(maxDim * 6, maxDim * 6);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -containerDims[1] / 2 - 5;
            ground.receiveShadow = true;
            scene.add(ground);

            // Add factory building silhouettes in background
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.9
            });

            // Large warehouse building
            const warehouse = new THREE.Mesh(
                new THREE.BoxGeometry(maxDim * 3, maxDim * 2, maxDim),
                buildingMaterial
            );
            warehouse.position.set(0, maxDim * 0.5, -maxDim * 4);
            warehouse.receiveShadow = true;
            warehouse.castShadow = true;
            scene.add(warehouse);

            // Smokestack
            const smokestack = new THREE.Mesh(
                new THREE.CylinderGeometry(maxDim * 0.15, maxDim * 0.2, maxDim * 2, 8),
                buildingMaterial
            );
            smokestack.position.set(maxDim * 1.5, maxDim * 1, -maxDim * 4);
            smokestack.receiveShadow = true;
            smokestack.castShadow = true;
            scene.add(smokestack);

            // Create container outline (wireframe)

            const containerGeometry = new THREE.BoxGeometry(containerDims[0], containerDims[1], containerDims[2]);
            const containerEdges = new THREE.EdgesGeometry(containerGeometry);
            const containerLine = new THREE.LineSegments(containerEdges, new THREE.LineBasicMaterial({ color: 0x667eea, linewidth: 2 }));
            scene.add(containerLine);

            // Calculate center of container
            const centerX = 0;
            const centerY = 0;
            const centerZ = 0;

            // Create procedural texture for charcoal bags (burlap/woven material)
            const bagTextureCanvas = document.createElement('canvas');
            bagTextureCanvas.width = 256;
            bagTextureCanvas.height = 256;
            const bagCtx = bagTextureCanvas.getContext('2d');

            // Base burlap color
            bagCtx.fillStyle = '#8B7355';
            bagCtx.fillRect(0, 0, 256, 256);

            // Add woven texture pattern
            for (let i = 0; i < 256; i += 4) {
                bagCtx.strokeStyle = `rgba(139, 115, 85, ${0.3 + Math.random() * 0.3})`;
                bagCtx.lineWidth = 2;
                bagCtx.beginPath();
                bagCtx.moveTo(i, 0);
                bagCtx.lineTo(i, 256);
                bagCtx.stroke();

                bagCtx.beginPath();
                bagCtx.moveTo(0, i);
                bagCtx.lineTo(256, i);
                bagCtx.stroke();
            }

            // Add random spots for realistic dirt/wear
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const size = Math.random() * 3 + 1;
                bagCtx.fillStyle = `rgba(50, 40, 30, ${Math.random() * 0.3})`;
                bagCtx.fillRect(x, y, size, size);
            }

            const bagTexture = new THREE.CanvasTexture(bagTextureCanvas);
            bagTexture.wrapS = THREE.RepeatWrapping;
            bagTexture.wrapT = THREE.RepeatWrapping;

            // Create wood texture for pallets
            const woodTextureCanvas = document.createElement('canvas');
            woodTextureCanvas.width = 256;
            woodTextureCanvas.height = 256;
            const woodCtx = woodTextureCanvas.getContext('2d');

            // Base wood color
            woodCtx.fillStyle = '#8B6914';
            woodCtx.fillRect(0, 0, 256, 256);

            // Wood grain lines
            for (let i = 0; i < 256; i += 8) {
                woodCtx.strokeStyle = `rgba(101, 67, 33, ${0.2 + Math.random() * 0.3})`;
                woodCtx.lineWidth = 1 + Math.random() * 2;
                woodCtx.beginPath();
                woodCtx.moveTo(0, i + Math.random() * 4 - 2);
                woodCtx.lineTo(256, i + Math.random() * 4 - 2);
                woodCtx.stroke();
            }

            const woodTexture = new THREE.CanvasTexture(woodTextureCanvas);
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;

            // Create bags
            const bagL = config.bagDims.l;
            const bagW = config.bagDims.w;
            const bagH = config.bagDims.h;

            // Get pallet dimensions (possibly rotated)
            const actualPalletL = config.palletDims.l;
            const actualPalletW = config.palletDims.w;

            // Starting positions
            const startX = -containerDims[0] / 2;
            const startY = -containerDims[1] / 2;
            const startZ = -containerDims[2] / 2;

            // Iterate through pallets
            for (let pz = 0; pz < config.palletLayout.z; pz++) {
                for (let py = 0; py < config.palletLayout.y; py++) {
                    for (let px = 0; px < config.palletLayout.x; px++) {
                        // Pallet base position
                        const palletX = startX + px * actualPalletL + actualPalletL / 2;
                        const palletY = startY + pz * palletH;
                        const palletZ = startZ + py * actualPalletW + actualPalletW / 2;

                        // Create visible pallet base
                        const palletThickness = 10; // 10cm thick pallet
                        const palletGeometry = new THREE.BoxGeometry(actualPalletL, palletThickness, actualPalletW);
                        const palletMaterial = new THREE.MeshStandardMaterial({
                            map: woodTexture,
                            roughness: 0.9,
                            metalness: 0.1,
                            color: 0xaa8844
                        });
                        const palletMesh = new THREE.Mesh(palletGeometry, palletMaterial);
                        palletMesh.position.set(palletX, palletY - palletThickness / 2, palletZ);
                        palletMesh.castShadow = true;
                        palletMesh.receiveShadow = true;
                        scene.add(palletMesh);

                        // Add pallet outline for clarity
                        const palletEdges = new THREE.EdgesGeometry(palletGeometry);
                        const palletOutline = new THREE.LineSegments(palletEdges,
                            new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 3 }));
                        palletMesh.add(palletOutline);

                        // Add "PALLET" label on top for clarity
                        const labelCanvas = document.createElement('canvas');
                        labelCanvas.width = 256;
                        labelCanvas.height = 128;
                        const labelCtx = labelCanvas.getContext('2d');
                        labelCtx.fillStyle = '#000000';
                        labelCtx.fillRect(0, 0, 256, 128);
                        labelCtx.fillStyle = '#FFFF00';
                        labelCtx.font = 'bold 48px Arial';
                        labelCtx.textAlign = 'center';
                        labelCtx.fillText('PALLET', 128, 70);

                        const labelTexture = new THREE.CanvasTexture(labelCanvas);
                        const labelMaterial = new THREE.MeshBasicMaterial({
                            map: labelTexture,
                            transparent: true,
                            opacity: 0.8
                        });
                        const labelGeometry = new THREE.PlaneGeometry(actualPalletL * 0.6, actualPalletL * 0.3);
                        const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                        labelMesh.rotation.x = -Math.PI / 2;
                        labelMesh.position.set(palletX, palletY + 1, palletZ);
                        scene.add(labelMesh);

                        // Iterate through bag layers on this pallet
                        for (let layer = 0; layer < config.bagLayout.totalLayers; layer++) {
                            const isOrientation1 = (layer % 2 === 0);
                            const cols = isOrientation1 ? config.bagLayout.orientation1.x : config.bagLayout.orientation2.x;
                            const rows = isOrientation1 ? config.bagLayout.orientation1.y : config.bagLayout.orientation2.y;

                            // Determine bag dimensions for this orientation
                            let currentBagL, currentBagW;
                            if (isOrientation1) {
                                currentBagL = bagL;
                                currentBagW = bagW;
                            } else {
                                currentBagL = bagW;
                                currentBagW = bagL;
                            }

                            // Starting position for bags on this pallet
                            const bagStartX = palletX - actualPalletL / 2;
                            const bagStartZ = palletZ - actualPalletW / 2;

                            for (let by = 0; by < rows; by++) {
                                for (let bx = 0; bx < cols; bx++) {
                                    const bagX = bagStartX + bx * currentBagL + currentBagL / 2;
                                    const bagY = palletY + layer * bagH + bagH / 2;
                                    const bagZ = bagStartZ + by * currentBagW + currentBagW / 2;

                                    // Create bag mesh
                                    const geometry = new THREE.BoxGeometry(currentBagL, bagH, currentBagW);

                                    // Use textured material with slight color variation for different orientations
                                    const hue = isOrientation1 ? 0.1 : 0.08;
                                    const tintColor = new THREE.Color().setHSL(hue, 0.3, 0.45);

                                    const material = new THREE.MeshStandardMaterial({
                                        map: bagTexture,
                                        color: tintColor,
                                        roughness: 0.95,
                                        metalness: 0.0,
                                        transparent: false
                                    });

                                    const mesh = new THREE.Mesh(geometry, material);
                                    mesh.castShadow = true;
                                    mesh.receiveShadow = true;

                                    // Store original position for explosion
                                    mesh.userData.originalPos = { x: bagX, y: bagY, z: bagZ };
                                    mesh.userData.centerOffset = {
                                        x: bagX - centerX,
                                        y: bagY - centerY,
                                        z: bagZ - centerZ
                                    };

                                    mesh.position.set(bagX, bagY, bagZ);

                                    // Add edge outline
                                    const edges = new THREE.EdgesGeometry(geometry);
                                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }));
                                    mesh.add(line);

                                    scene.add(mesh);
                                    bagMeshes.push(mesh);
                                }
                            }
                        }
                    }
                }
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Update controls for smooth damping
                controls.update();

                renderer.render(scene, camera);
            }
            animate();

            // Setup explosion slider
            const slider = document.getElementById('explosionSlider');
            const valueDisplay = document.getElementById('explosionValue');

            slider.oninput = function() {
                explosionFactor = this.value / 100;
                valueDisplay.textContent = this.value + '%';
                updateExplosion();
            };

            // Handle window resize
            window.addEventListener('resize', function() {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        }

        function updateExplosion() {
            bagMeshes.forEach(mesh => {
                const orig = mesh.userData.originalPos;
                const offset = mesh.userData.centerOffset;

                // Move bags away from center based on explosion factor
                mesh.position.x = orig.x + offset.x * explosionFactor * 2;
                mesh.position.y = orig.y + offset.y * explosionFactor * 2;
                mesh.position.z = orig.z + offset.z * explosionFactor * 2;
            });
        }

        // MUSIC SYSTEM WITH 4 SONGS!
        let audioContext;
        let musicPlaying = false;
        let musicEnabled = true;
        let musicLoopTimeout = null;
        let currentSong = 'happy';

        function playNote(freq, startTime, duration, type = 'sine', volume = 0.1, masterGain) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(volume, startTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        function toggleMusic() {
            musicEnabled = !musicEnabled;
            const btn = document.getElementById('musicToggle');
            const icon = btn.querySelector('.music-icon');
            const status = document.getElementById('musicStatus');

            if (musicEnabled) {
                btn.classList.remove('muted');
                icon.textContent = 'ðŸ”Š';
                status.textContent = 'Music ON';
                if (!musicPlaying) {
                    playCurrentSong();
                }
            } else {
                btn.classList.add('muted');
                icon.textContent = 'ðŸ”‡';
                status.textContent = 'Music OFF';
                stopMusic();
            }
        }

        function changeSong() {
            currentSong = document.getElementById('musicSelector').value;
            if (musicEnabled) {
                stopMusic();
                setTimeout(() => playCurrentSong(), 100);
            }
        }

        function stopMusic() {
            if (musicLoopTimeout) {
                clearTimeout(musicLoopTimeout);
                musicLoopTimeout = null;
            }
            musicPlaying = false;
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        }

        function playCurrentSong() {
            if (!musicEnabled || musicPlaying) return;

            switch(currentSong) {
                case 'happy': playHappySong(); break;
                case 'sad': playSadSong(); break;
                case 'metal': playMetalSong(); break;
                case 'synthwave': playSynthwave(); break;
            }
        }

        // 1. HAPPY SONG - Upbeat and cheerful!
        function playHappySong() {
            if (musicPlaying) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                musicPlaying = true;
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 0.25;
                masterGain.connect(audioContext.destination);

                let time = audioContext.currentTime;
                const bpm = 140;
                const beat = 60 / bpm;

                const melody = [
                    {note: 523.25, time: 0, dur: beat*0.4}, {note: 587.33, time: beat*0.5, dur: beat*0.4},
                    {note: 659.25, time: beat*1, dur: beat*0.4}, {note: 783.99, time: beat*1.5, dur: beat*1.4},
                    {note: 659.25, time: beat*3, dur: beat*0.4}, {note: 587.33, time: beat*3.5, dur: beat*0.4},
                    {note: 523.25, time: beat*4, dur: beat*0.4}, {note: 659.25, time: beat*4.5, dur: beat*1.4},
                    {note: 698.46, time: beat*6, dur: beat*0.4}, {note: 783.99, time: beat*6.5, dur: beat*0.4},
                    {note: 880.00, time: beat*7, dur: beat*0.4}, {note: 1046.50, time: beat*7.5, dur: beat*1.4},
                    {note: 783.99, time: beat*9, dur: beat*0.4}, {note: 659.25, time: beat*9.5, dur: beat*0.4},
                    {note: 523.25, time: beat*10, dur: beat*1.8}
                ];

                melody.forEach(m => {
                    playNote(m.note, time + m.time, m.dur, 'square', 0.15, masterGain);
                    playNote(m.note * 1.01, time + m.time, m.dur, 'square', 0.08, masterGain);
                });

                for (let i = 0; i < 12; i++) {
                    playNote(130.81, time + i * beat, beat * 0.8, 'triangle', 0.3, masterGain);
                }

                for (let i = 0; i < 12; i++) {
                    const kick = audioContext.createOscillator();
                    const kickGain = audioContext.createGain();
                    kick.frequency.setValueAtTime(150, time + i * beat);
                    kick.frequency.exponentialRampToValueAtTime(0.01, time + i * beat + 0.15);
                    kickGain.gain.setValueAtTime(0.4, time + i * beat);
                    kickGain.gain.exponentialRampToValueAtTime(0.001, time + i * beat + 0.15);
                    kick.connect(kickGain);
                    kickGain.connect(masterGain);
                    kick.start(time + i * beat);
                    kick.stop(time + i * beat + 0.15);
                }

                musicLoopTimeout = setTimeout(() => {
                    musicPlaying = false;
                    if (musicEnabled) playHappySong();
                }, (beat * 12 * 1000) - 50);
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        // 2. SAD SONG - Slow and melancholic
        function playSadSong() {
            if (musicPlaying) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                musicPlaying = true;
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 0.2;
                masterGain.connect(audioContext.destination);

                let time = audioContext.currentTime;
                const bpm = 70; // Slow
                const beat = 60 / bpm;

                // Minor key melody (sad)
                const melody = [
                    {note: 440.00, time: 0, dur: beat*1.5}, {note: 392.00, time: beat*2, dur: beat*1.5},
                    {note: 349.23, time: beat*4, dur: beat*2}, {note: 329.63, time: beat*6, dur: beat*1.5},
                    {note: 293.66, time: beat*8, dur: beat*2}, {note: 261.63, time: beat*10, dur: beat*3}
                ];

                melody.forEach(m => {
                    playNote(m.note, time + m.time, m.dur, 'sine', 0.12, masterGain);
                    playNote(m.note * 0.5, time + m.time, m.dur, 'sine', 0.08, masterGain);
                });

                // Slow bass
                for (let i = 0; i < 8; i++) {
                    playNote(110.00, time + i * beat * 2, beat * 1.8, 'sine', 0.15, masterGain);
                }

                musicLoopTimeout = setTimeout(() => {
                    musicPlaying = false;
                    if (musicEnabled) playSadSong();
                }, (beat * 16 * 1000) - 50);
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        // 3. THRASH METAL - Fast and aggressive!
        function playMetalSong() {
            if (musicPlaying) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                musicPlaying = true;
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);

                let time = audioContext.currentTime;
                const bpm = 180; // FAST!
                const beat = 60 / bpm;

                // Power chord riff (distorted!)
                const riff = [
                    {note: 82.41, time: 0, dur: beat*0.5}, {note: 82.41, time: beat*0.5, dur: beat*0.5},
                    {note: 110.00, time: beat*1, dur: beat*0.5}, {note: 82.41, time: beat*1.5, dur: beat*0.5},
                    {note: 73.42, time: beat*2, dur: beat*0.5}, {note: 73.42, time: beat*2.5, dur: beat*0.5},
                    {note: 82.41, time: beat*3, dur: beat*0.5}, {note: 98.00, time: beat*3.5, dur: beat*0.5}
                ];

                for (let bar = 0; bar < 4; bar++) {
                    riff.forEach(r => {
                        const t = time + r.time + bar * beat * 4;
                        // Heavy distorted guitar (multiple oscillators!)
                        playNote(r.note, t, r.dur, 'sawtooth', 0.15, masterGain);
                        playNote(r.note * 2, t, r.dur, 'square', 0.1, masterGain);
                        playNote(r.note * 1.5, t, r.dur, 'sawtooth', 0.08, masterGain);
                    });
                }

                // Double kick drums (FAST!)
                for (let i = 0; i < 64; i++) {
                    const kick = audioContext.createOscillator();
                    const kickGain = audioContext.createGain();
                    kick.frequency.setValueAtTime(80, time + i * beat * 0.25);
                    kick.frequency.exponentialRampToValueAtTime(0.01, time + i * beat * 0.25 + 0.1);
                    kickGain.gain.setValueAtTime(0.5, time + i * beat * 0.25);
                    kickGain.gain.exponentialRampToValueAtTime(0.001, time + i * beat * 0.25 + 0.1);
                    kick.connect(kickGain);
                    kickGain.connect(masterGain);
                    kick.start(time + i * beat * 0.25);
                    kick.stop(time + i * beat * 0.25 + 0.1);
                }

                musicLoopTimeout = setTimeout(() => {
                    musicPlaying = false;
                    if (musicEnabled) playMetalSong();
                }, (beat * 16 * 1000) - 50);
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        // 4. SYNTHWAVE - Retro 80s vibes!
        function playSynthwave() {
            if (musicPlaying) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                musicPlaying = true;
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 0.25;
                masterGain.connect(audioContext.destination);

                let time = audioContext.currentTime;
                const bpm = 120;
                const beat = 60 / bpm;

                // Retro synth lead
                const melody = [
                    {note: 659.25, time: 0, dur: beat*0.5}, {note: 587.33, time: beat*0.5, dur: beat*0.5},
                    {note: 523.25, time: beat*1, dur: beat*0.5}, {note: 587.33, time: beat*1.5, dur: beat*0.5},
                    {note: 659.25, time: beat*2, dur: beat*1}, {note: 783.99, time: beat*3, dur: beat*1},
                    {note: 880.00, time: beat*4, dur: beat*0.5}, {note: 783.99, time: beat*4.5, dur: beat*0.5},
                    {note: 659.25, time: beat*5, dur: beat*0.5}, {note: 587.33, time: beat*5.5, dur: beat*0.5},
                    {note: 523.25, time: beat*6, dur: beat*2}
                ];

                melody.forEach(m => {
                    playNote(m.note, time + m.time, m.dur, 'sawtooth', 0.12, masterGain);
                    playNote(m.note * 1.005, time + m.time, m.dur, 'sawtooth', 0.12, masterGain); // Chorus
                });

                // Arpeggio bassline
                const arp = [261.63, 329.63, 392.00, 523.25];
                for (let i = 0; i < 32; i++) {
                    playNote(arp[i % 4], time + i * beat * 0.25, beat * 0.2, 'triangle', 0.15, masterGain);
                }

                // Sidechained kick
                for (let i = 0; i < 8; i++) {
                    const kick = audioContext.createOscillator();
                    const kickGain = audioContext.createGain();
                    kick.frequency.setValueAtTime(120, time + i * beat);
                    kick.frequency.exponentialRampToValueAtTime(0.01, time + i * beat + 0.2);
                    kickGain.gain.setValueAtTime(0.45, time + i * beat);
                    kickGain.gain.exponentialRampToValueAtTime(0.001, time + i * beat + 0.2);
                    kick.connect(kickGain);
                    kickGain.connect(masterGain);
                    kick.start(time + i * beat);
                    kick.stop(time + i * beat + 0.2);
                }

                musicLoopTimeout = setTimeout(() => {
                    musicPlaying = false;
                    if (musicEnabled) playSynthwave();
                }, (beat * 8 * 1000) - 50);
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        // Auto-play on load
        window.addEventListener('load', () => {
            if (musicEnabled) playCurrentSong();
        });

        // Fallback on first click
        document.addEventListener('click', () => {
            if (!musicPlaying && musicEnabled) {
                playCurrentSong();
            }
        }, { once: true });
    </script>
</body>
</html>
